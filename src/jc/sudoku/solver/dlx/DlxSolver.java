package jc.sudoku.solver.dlx;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jc.sudoku.diagram.Column;
import jc.sudoku.diagram.Diagram;
import jc.sudoku.diagram.Node;
import jc.sudoku.solver.Solver;

// Generalized exact cover.
//
// This class implements the algorithm discussed in Knuth's 'Dancing Links' paper at
// http://arxiv.org/abs/cs/0011047. Adapted from Knuth's source at
// http://www-cs-faculty.stanford.edu/~uno/programs/dance.w.
//
// Given a matrix whose elements are 0 or 1, the problem is to find all subsets of its rows
// which give a sum of at most 1 in all columns and exactly 1 in all 'primary' columns.
//
// The matrix is built by first specifying the names of the columns, using the addColumn method.
// Then the rows are added by calling addRow for each row, and specifying the column names where
// 1 appears in that row.
//
// The covers are generated by calling the solve method, which returns the number of solutions found.
// You may optionally set the solution spacing to control the quantity of diagnostic output.
//
// The program logs diagnostic info:
// - the number of solutions and the total number of link updates.
// - it also logs every nth solution, with log level 'info', where n is the solution spacing value
// - it also logs the full search tree at log level debug
// - even more diagnostics are logged at log level trace
//
public class DlxSolver implements Solver {
	private static final Logger LOG = LoggerFactory.getLogger(DlxSolver.class);

	public DlxSolver(Diagram diagram) {
		this.diagram = diagram;
	}
	
	// limits
	static final int MAX_LEVEL = 150; 		// max rows in a solution
	static final int MAX_DEGREE = 1000;		// max branches per search tree node
	
	// settings
	int spacing = 1;						// only show every nth solution
	
	// the Sudoku diagram
	Diagram diagram;
	
	// sets the 'spacing' value for just printing every so many solutions 
	public void setSpacing(int spacing) {
		if (spacing > 0)
			this.spacing = spacing;
	}
	
	// some performance statistics
	int count = 0; 													// number of solutions found so far
	long updates = 0;												// number of times we deleted a list element
	long[][] profile = new long[MAX_LEVEL][MAX_DEGREE]; 			// tree nodes of given level and degree
	long[] profileUpdates = new long[MAX_LEVEL]; 					// number of updates at a given level
	int maxBranchFactor = 0; 										// maximum branching factor actually needed
	int maxLevel = 0; 												// maximum level actually reached

	// Backtracking.
	//
	// Our strategy for generating all exact covers will be to repeatedly
	// choose always the column that appears to be hardest to cover, namely the
	// column with shortest list, from all columns that still need to be covered.
	// And we explore all possibilities via depth-first search.

	// The neat part of this algorithm is the way the lists are maintained.
	// Depth-first search means last-in-first-out maintenance of data structures;
	// and it turns out that we need no auxiliary tables to undelete elements from
	// lists when backing up. The nodes removed from doubly linked lists remember
	// their former neighbors, because we do no garbage collection.

	// The basic operation is 'covering a column.' This means removing it
	// from the list of columns needing to be covered, and 'blocking' its
	// rows: removing nodes from other lists whenever they belong to a row of
	// a node in this column's list.
	//
	private void backtrack(int level) {
		Column bestCol = findBestBranchingColumn(level);
		int k = diagram.cover(level, bestCol);
		updates += k;
		profileUpdates[level] += k;
		
		for (Node currNode = bestCol.head.down; currNode != bestCol.head; currNode = currNode.down) {
			diagram.solution.push(currNode);
			LOG.debug("Level: {}, row {}", level, diagram.rowName(currNode));
			
			diagram.coverNodeColumns(level, currNode);
			if (diagram.rootColumn.next == diagram.rootColumn) {
				recordSolution(level);
			} else {
				backtrack(level+1);
			}

			diagram.uncoverNodeColumns(currNode);
			diagram.solution.pop();
		}
		
		diagram.uncover(bestCol);
	}
	
	// finds the column with the minimum branching factor - i.e. containing
	// the fewest candidate rows. 
	private Column findBestBranchingColumn(int level) {
		int minlen = Integer.MAX_VALUE;

		Column bestCol = null;
		StringBuilder sb = new StringBuilder();
		for (Column c = diagram.rootColumn.next; c != diagram.rootColumn; c = c.next) {
			if (LOG.isTraceEnabled())
				sb.append(String.format(" %s(%d)", c.name, c.len));
			
			if (c.len < minlen) {
				bestCol = c;
				minlen = c.len;
			}
		}
		LOG.trace("Level: {}: {}", level, sb.toString());
		
		if (LOG.isInfoEnabled()) {
			if (level > maxLevel) {
				if (level >= MAX_LEVEL)
					throw new UnsupportedOperationException("Too many levels");
				maxLevel = level;
			}
			if (minlen > maxBranchFactor) {
				if (minlen >= MAX_DEGREE)
					throw new UnsupportedOperationException("Too many branches");
				maxBranchFactor = minlen;
			}
			profile[level][minlen]++;
			LOG.trace("  branching on {} ({})", bestCol.name,minlen);
		}
		return bestCol;
	}
	
	private void recordSolution(int level) {
		count++;
		if (LOG.isInfoEnabled()) {
			profile[level+1][0]++;
			if ((count % spacing) == 0) {
				LOG.info("=== Solution {}:\n", count);
				for (Node node : diagram.solution)
					LOG.info(diagram.rowName(node));
			}
		}
		
		
	}
	
	void logSearchTreeProfile() {
		if (!LOG.isInfoEnabled())
			return;
		
		long tot, subtot;
		tot = 1; 		// the root node doesn't show up in the profile
		
		for (int level = 1; level <= maxLevel+1; level++) {
			subtot=0;
			
			StringBuilder sb = new StringBuilder();
			sb.append(String.format("Level %d:", level));
			
			for (int k = 0; k <= maxBranchFactor; k++) {
				sb.append(String.format(" %6d", profile[level][k]));
				subtot += profile[level][k];
			}
			tot += subtot;

			sb.append(String.format(" %15d nodes, %15d updates", subtot, profileUpdates[level-1]));
			LOG.info(sb.toString());
		}
		LOG.info("Total {} nodes.", tot);
	}
	
	private void logColumnLengths() {
		if (!LOG.isTraceEnabled())
			return;
		
		StringBuilder sb = new StringBuilder();
		sb.append("Final column lengths");
		for (Column c = diagram.rootColumn.next; c != diagram.rootColumn; c = c.next)
			sb.append(String.format(" %s(%d)", c.name, c.len));
		LOG.trace(sb.toString());
	}
	
	// Solve the puzzle and logs some diagnostic/performance data, return number
	// of solutions found
	//
	public int solve() {
		if (diagram.rootColumn.next == diagram.rootColumn)
			throw new UnsupportedOperationException("No primary columns were defined");
		
		backtrack(0);

		logColumnLengths();
		
		LOG.info("Altogether {} solutions, after {} updates.", count, updates);
		logSearchTreeProfile();
		
		return count;
	}
}
