package jc.dlx.solver;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jc.dlx.diagram.IColumn;
import jc.dlx.diagram.IDiagram;
import jc.dlx.diagram.INode;
import jc.dlx.diagram.IRow;
import jc.sudoku.solver.Solver;

// Generalized exact cover.
//
// This class implements the algorithm discussed in Knuth's 'Dancing Links'
// paper at http://arxiv.org/abs/cs/0011047. Adapted from Knuth's source at
// http://www-cs-faculty.stanford.edu/~uno/programs/dance.w.
//
// Given a matrix whose elements are 0 or 1, the problem is to find all subsets
// of its rows which give a sum of at most 1 in all columns and exactly 1 in all
// 'primary' columns.
//
// The matrix is built by first specifying the names of the columns, using the
// addColumn method. Then the rows are added by calling addRow for each row,
// and specifying the column names where 1 appears in that row.
//
// The covers are generated by calling the solve method, which returns the number
// of solutions found. You may optionally set the solution spacing to control the
// quantity of diagnostic output.
//
// The program logs diagnostic info:
// - the number of solutions and the total number of link updates.
// - it also logs every nth solution, with log level 'info', where n is the
//   solution spacing value
// - it also logs the full search tree at log level debug
// - even more diagnostics are logged at log level trace
//
public class DlxSolver implements Solver {
	private static final Logger LOG = LoggerFactory.getLogger(DlxSolver.class);

	public DlxSolver(IDiagram diagram) {
		this.diagram = diagram;
	}
	
	// limits
	static final int MAX_LEVEL = 150; 		// max rows in a solution
	static final int MAX_DEGREE = 1000;		// max branches per search tree node
	
	// settings
	int spacing = 1;						// only show every nth solution
	
	// the Sudoku diagram
	IDiagram diagram;
	
	// sets the 'spacing' value for just printing every so many solutions 
	public void setSpacing(int spacing) {
		if (spacing > 0)
			this.spacing = spacing;
	}
	
	// some performance statistics
	int count = 0; 										// number of solutions found so far
	long updates = 0;									// number of times we deleted a list element
	long[][] profile = new long[MAX_LEVEL][MAX_DEGREE]; // tree nodes of given level and degree
	long[] profileUpdates = new long[MAX_LEVEL]; 		// number of updates at a given level
	int maxBranchFactor = 0; 							// maximum branching factor actually needed
	int maxLevel = 0; 									// maximum level actually reached

	// Backtracking.
	//
	// Our strategy for generating all exact covers will be to repeatedly
	// choose always the column that appears to be hardest to cover, namely the
	// column with shortest list, from all columns that still need to be covered.
	// And we explore all possibilities via depth-first search.

	// The neat part of this algorithm is the way the lists are maintained.
	// Depth-first search means last-in-first-out maintenance of data structures;
	// and it turns out that we need no auxiliary tables to undelete elements from
	// lists when backing up. The nodes removed from doubly linked lists remember
	// their former neighbors, because we do no garbage collection.

	// The basic operation is 'covering a column.' This means removing it
	// from the list of columns needing to be covered, and 'blocking' its
	// rows: removing nodes from other lists whenever they belong to a row of
	// a node in this column's list.
	//
	private void backtrack(int level) {
		IColumn bestCol = findBestBranchingColumn(level);
		int k = diagram.cover(level, bestCol);
		updates += k;
		profileUpdates[level] += k;
		
		for (INode currNode = bestCol.getHead().getDown();
				currNode != bestCol.getHead();
				currNode = currNode.getDown()) {
			diagram.pushSolution(currNode);
			LOG.debug("Level: {}, row {}", level, currNode.toString());
			
			diagram.coverNodeColumns(level, currNode);
			
			if (diagram.isSolved()) {
				recordSolution(level);
			} else {
				backtrack(level+1);
			}

			diagram.uncoverNodeColumns(currNode);
			diagram.popSolution();
		}
		
		diagram.uncover(bestCol);
	}
	
	// Finds the column with the minimum branching factor - i.e. containing
	// the fewest candidate rows. 
	private IColumn findBestBranchingColumn(int level) {
		int minlen = Integer.MAX_VALUE;

		IColumn bestCol = null;
		StringBuilder sb = new StringBuilder();
		for (IColumn c : diagram.getActiveColumns()) {
			if (LOG.isTraceEnabled())
				sb.append(String.format(" %s(%d)", c.getName(), c.getLength()));
			
			if (c.getLength() < minlen) {
				bestCol = c;
				minlen = c.getLength();
			}
		}
		LOG.trace("Level: {}: {}", level, sb.toString());
		
		if (LOG.isInfoEnabled()) {
			if (level > maxLevel) {
				if (level >= MAX_LEVEL)
					throw new UnsupportedOperationException("Too many levels");
				maxLevel = level;
			}
			if (minlen > maxBranchFactor) {
				if (minlen >= MAX_DEGREE)
					throw new UnsupportedOperationException("Too many branches");
				maxBranchFactor = minlen;
			}
			profile[level][minlen]++;
			LOG.trace("  branching on {} ({})", bestCol.getName(), minlen);
		}
		return bestCol;
	}
	
	// Logs the set of rows in the current solution
	private void recordSolution(int level) {
		count++;
		if (LOG.isInfoEnabled()) {
			profile[level+1][0]++;
			if ((count % spacing) == 0) {
				LOG.info("=== Solution {}:\n", count);
				for (IRow row : diagram.getSolution())
					LOG.info(row.toString());
			}
		}
	}
	
	// Logs statistics on branching and number of node updates at
	// each level of the search
	void logSearchTreeProfile() {
		if (!LOG.isInfoEnabled())
			return;
		
		long tot, subtot;
		tot = 1; 		// the root node doesn't show up in the profile
		
		for (int level = 1; level <= maxLevel+1; level++) {
			subtot=0;
			
			StringBuilder sb = new StringBuilder();
			sb.append(String.format("Level %d:", level));
			
			for (int k = 0; k <= maxBranchFactor; k++) {
				sb.append(String.format(" %6d", profile[level][k]));
				subtot += profile[level][k];
			}
			tot += subtot;

			sb.append(String.format(" %15d nodes, %15d updates",
					subtot, profileUpdates[level-1]));
			LOG.info(sb.toString());
		}
		LOG.info("Total {} nodes.", tot);
	}
	
	// Logs the column lengths, just used to check that when backtracking
	// is complete, the matrix is restored to its initial state
	private void logColumnLengths() {
		if (!LOG.isTraceEnabled())
			return;
		
		StringBuilder sb = new StringBuilder();
		sb.append("Final column lengths");
		for (IColumn c : diagram.getActiveColumns())
			sb.append(String.format(" %s(%d)", c.getName(), c.getLength()));
		LOG.trace(sb.toString());
	}
	
	// Solve the puzzle and logs some diagnostic/performance data, return number
	// of solutions found
	public int solve() {
		if (diagram.getRootColumn().getNext() == diagram.getRootColumn())
			throw new UnsupportedOperationException("No primary columns were defined");
		
		// call recursive backtracking solve routine
		backtrack(0);

		// just to check the diagram is back to its original state
		logColumnLengths();
		
		// log some statistics
		LOG.info("Altogether {} solutions, after {} updates.", count, updates);
		logSearchTreeProfile();
		
		return count;
	}
}
